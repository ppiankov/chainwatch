# Chainwatch v0.1.1: Denylist Usage Guide

**Version:** 0.1.1
**Status:** Stable
**Target:** Clawbot and browser-based autonomous agents

---

## What's New in v0.1.1

**Simple, working protection against unauthorized purchases and credential leaks.**

v0.1.1 adds a denylist that blocks dangerous resources BEFORE your agent can access them:
- Checkout/payment URLs (prevents $3000 course purchases)
- Credential files (prevents SSH key/AWS credential leaks)
- Dangerous shell commands (prevents destructive operations)

**No approval workflow yet** - just hard blocks. Approval system comes in v0.2.0.

---

## Quick Start (30 Seconds)

### 1. Install/Upgrade

```bash
pip install --upgrade chainwatch
```

### 2. Initialize Denylist

```bash
chainwatch init-denylist
```

This creates `~/.chainwatch/denylist.yaml` with sane defaults.

### 3. Done

The denylist is automatically loaded by all Chainwatch-enforced operations.

---

## What Gets Blocked by Default

### Checkout/Payment URLs

```
/checkout
/payment
/billing
/subscribe
/cart/confirm
/order/place
/upgrade
stripe.com/checkout
paddle.com/checkout
paypal.com/checkoutnow
```

**Why:** Prevents agent from completing purchases with saved payment methods.

### Credential Files

```
~/.ssh/id_rsa
~/.ssh/id_ed25519
~/.aws/credentials
~/.config/gcloud/credentials
**/.env
**/secrets.json
**/credentials.json
```

**Why:** Prevents agent from reading sensitive credentials and leaking them.

### Dangerous Commands

```
rm -rf /
dd if=/dev/zero
mkfs
fdisk
sudo su
sudo -i
curl ... | sh
wget ... | sh
```

**Why:** Prevents destructive operations that can't be undone.

---

## How It Works

### 1. Automatic Loading

When FileGuard or any Chainwatch wrapper evaluates an action:

```python
from chainwatch.wrappers.file_ops import FileGuard

with FileGuard(purpose="research", actor={...}) as guard:
    with open("~/.ssh/id_rsa", "r") as f:  # BLOCKED
        data = f.read()
```

The denylist is automatically loaded and checked **before** any other policy rules.

### 2. Hard Block (No Approval)

If a resource matches the denylist:
- Decision: **DENY** (hard block, not `REQUIRE_APPROVAL`)
- No way to proceed without removing the pattern from the denylist
- Clear error message showing which pattern matched

Example error:
```
EnforcementError: Denylisted: URL matches denylist pattern: /checkout
```

### 3. Priority

Denylist check happens **first**, before:
- Risk scoring
- Purpose-bound rules
- Sensitivity classification

If it's on the denylist, it's blocked. Period.

---

## Customizing the Denylist

### Edit the File

```bash
vim ~/.chainwatch/denylist.yaml
```

### Add Your Own Patterns

```yaml
urls:
  - /checkout
  - /payment
  - internal-billing.company.com  # Block specific internal domain

files:
  - ~/.ssh/id_rsa
  - **/production.env  # Block production env files
  - /etc/passwd  # Block system password file

commands:
  - rm -rf
  - kubectl delete  # Block Kubernetes deletions
  - terraform destroy  # Block infrastructure destruction
```

### Remove Patterns

Just delete the line or comment it out with `#`:

```yaml
urls:
  - /checkout
  # - /subscribe  # Commented out - subscriptions allowed
```

### Pattern Syntax

**URLs:**
- Substring matching, case-insensitive
- `/checkout` matches `https://example.com/checkout/confirm`
- `stripe.com` matches any URL containing "stripe.com"

**Files:**
- Glob patterns supported: `**/secrets.json` matches anywhere
- Tilde expansion: `~/.ssh/id_rsa` expands to full path
- Exact path matching: `/etc/passwd` matches only that file

**Commands:**
- Regex patterns, case-insensitive
- `rm -rf` matches "rm -rf /data" and "RM -RF /tmp"
- `.*sudo.*` matches any command containing "sudo"

---

## Testing Your Denylist

### Run the Demo

```bash
python examples/denylist_demo.py
```

Expected output:
```
✓ BLOCKED: Agent cannot proceed to checkout
✓ BLOCKED: Agent cannot access SSH private key
✓ ALLOWED: Normal browsing proceeds
```

### Check a Specific Pattern

```python
from chainwatch.denylist import Denylist

denylist = Denylist.load()

# Test a URL
blocked, reason = denylist.is_blocked(
    "https://coursera.org/checkout",
    "browser_navigate"
)
print(f"Blocked: {blocked}, Reason: {reason}")
```

---

## Integration with Clawbot

### Current Limitation

v0.1.1 does NOT automatically wrap Clawbot. You must integrate manually.

### Manual Integration (Python Agents)

If your Clawbot setup uses Python tool implementations:

```python
from chainwatch.denylist import Denylist
from chainwatch.policy import evaluate
from chainwatch.types import Action, TraceState
from chainwatch.enforcement import EnforcementError, enforce

# Load denylist once
denylist = Denylist.load()

# In your tool wrapper
def browser_navigate(url):
    action = Action(
        tool="browser_navigate",
        resource=url,
        operation="navigate"
    )

    policy_result = evaluate(
        action=action,
        state=TraceState(trace_id="session-123"),
        purpose="research",
        denylist=denylist  # Pass denylist explicitly
    )

    if policy_result.decision == "deny":
        raise EnforcementError(policy_result.reason)

    # Proceed with navigation
    ...
```

### Full Clawbot Wrapper (v0.2.0)

Coming in v0.2.0:
- `chainwatch wrap clawbot` - Automatic interception
- Browser checkout gate - Blocks purchases without manual integration
- MCP tool gateway - Universal tool interception

For now, v0.1.1 provides the **policy logic** and **denylist matching**. You hook it into your tools manually.

---

## Upgrading from v0.1.0

### What Changed

- Added `denylist.py` module
- Added `pyyaml` dependency
- Added `chainwatch init-denylist` CLI command
- `policy.evaluate()` now accepts optional `denylist` parameter
- Denylist checked first (before risk scoring)

### Breaking Changes

**None.** v0.1.1 is fully backward compatible with v0.1.0.

If you don't create a denylist file, Chainwatch uses built-in defaults.

### Migration Steps

```bash
pip install --upgrade chainwatch
chainwatch init-denylist
# Done. Existing code keeps working.
```

---

## Limitations

### What v0.1.1 Does NOT Do

- ❌ Automatic Clawbot wrapping (v0.2.0)
- ❌ Approval workflow (v0.2.0)
- ❌ Browser interception (v0.2.0)
- ❌ Network proxy mode (v0.3.0)

### What v0.1.1 DOES Do

- ✅ Pattern-based resource blocking
- ✅ Default patterns for common threats
- ✅ YAML configuration
- ✅ Integration with existing policy.evaluate()
- ✅ Works with FileGuard out of the box

**v0.1.1 prevents the "$3000 purchase" incident IF you integrate it.**

---

## Troubleshooting

### Denylist Not Loading

**Symptom:** Agent accesses denylisted resources without error.

**Fix:**
1. Check file exists: `ls ~/.chainwatch/denylist.yaml`
2. If missing: `chainwatch init-denylist`
3. Verify integration: Pass `denylist=Denylist.load()` to `evaluate()`

### False Positives

**Symptom:** Legitimate resources are blocked.

**Fix:**
1. Edit denylist: `vim ~/.chainwatch/denylist.yaml`
2. Remove or comment out the pattern
3. Save and retry

### False Negatives

**Symptom:** Dangerous resources are not blocked.

**Fix:**
1. Add pattern to denylist: `vim ~/.chainwatch/denylist.yaml`
2. Test with: `python examples/denylist_demo.py`

### Denylist Ignored

**Symptom:** Policy evaluates but denylist patterns don't trigger.

**Fix:**
Check that you're passing the denylist parameter:

```python
# WRONG (denylist not passed)
policy_result = evaluate(action=action, state=state, purpose="research")

# CORRECT (denylist passed)
denylist = Denylist.load()
policy_result = evaluate(action=action, state=state, purpose="research", denylist=denylist)
```

---

## Next Steps

### For Immediate Protection

1. `chainwatch init-denylist`
2. Review patterns: `cat ~/.chainwatch/denylist.yaml`
3. Add your specific threats (internal domains, prod files, etc.)
4. Integrate into your agent tool wrappers

### For v0.2.0 (Coming Soon)

Wait for:
- `chainwatch wrap clawbot` - Automatic interception
- Browser checkout gate - No manual integration needed
- Approval workflow - `chainwatch approve <id>` for gated actions

### Learn More

- Full roadmap: `docs/roadmap-clawbot.md`
- Browser wrapper spec: `docs/integrations/browser-checkout-gate.md`
- Changelog: `CHANGELOG.md`

---

**v0.1.1 ships working protection today. No ML. No guessing. Just deterministic blocking.**

**If it's on the denylist, it's blocked.**
