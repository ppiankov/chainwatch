# v0.2.0 Specification: Monotonic Boundary Accumulation

**Status:** Design specification (not yet implemented)
**Philosophy:** See `docs/irreversible-boundaries.md` and `docs/monotonic-irreversibility.md`
**Target:** v0.2.0 release

---

## Overview

v0.2.0 implements **monotonic boundary accumulation**: chain-aware irreversibility detection through zone-based state transitions.

**Core principle:** Boundaries accumulate, never disappear. Irreversibility only increases.

**Two boundary classes:**
1. **Execution boundaries** - actions that cannot be undone
2. **Authority boundaries** - instructions that cannot be un-accepted

Both use the same enforcement mechanism: monotonic state transitions with hard refusal.

---

## Zone Taxonomy (Execution Boundaries)

### Zone Definitions

Zones are **structural categories** that represent proximity to irreversibility.

```python
class Zone(Enum):
    # Commercial activity
    COMMERCIAL_INTENT = "commercial_intent"      # Browsing products, pricing
    COMMERCIAL_COMMITMENT = "commercial_commit"  # Cart, checkout intent

    # Credential handling
    CREDENTIAL_ADJACENT = "credential_adjacent"  # Near credential files
    CREDENTIAL_EXPOSED = "credential_exposed"    # Credential read into context

    # External communication
    EGRESS_CAPABLE = "egress_capable"            # Network connectivity established
    EGRESS_ACTIVE = "egress_active"              # External communication in progress

    # Data sensitivity
    SENSITIVE_DATA = "sensitive_data"            # PII, confidential data observed
    HIGH_VOLUME = "high_volume"                  # Large data accumulation
```

### Zone Detection Rules

**Pattern-based detection (deterministic):**

```yaml
# zone_detection_rules.yaml

commercial_intent:
  url_patterns:
    - /pricing
    - /products
    - /shop
    - /store
  file_patterns:
    - "**/pricing/**"
    - "**/catalog/**"

commercial_commitment:
  url_patterns:
    - /cart
    - /checkout
    - /payment
    - /billing
    - stripe.com/checkout
    - paddle.com/checkout
  file_patterns: []

credential_adjacent:
  file_patterns:
    - ~/.ssh/*
    - ~/.aws/*
    - ~/.config/gcloud/*
    - "**/.env*"
    - "**/secrets.*"
    - "**/credentials.*"
  command_patterns: []

credential_exposed:
  # Triggered when credential_adjacent file is READ
  actions:
    - read file matching credential_adjacent pattern

egress_capable:
  url_patterns:
    - "http://*"    # External HTTP detected
    - "https://*"   # External HTTPS detected
  command_patterns:
    - curl
    - wget
    - nc
    - telnet

egress_active:
  # Triggered when POST/PUT to external URL OR SMTP command
  actions:
    - POST/PUT request to external domain
    - SMTP send command

sensitive_data:
  file_patterns:
    - "**/hr/**"
    - "**/employee/**"
    - "**/salary/**"
    - "**/payroll/**"
    - "**/pii/**"

high_volume:
  # Triggered when volume_bytes > threshold
  threshold: 10_000_000  # 10MB
```

### Zone Combination Rules → Irreversibility Level

```python
class IrreversibilityLevel(Enum):
    SAFE = 0
    SENSITIVE = 1
    COMMITMENT = 2
    IRREVERSIBLE = 3

# Zone combinations that escalate irreversibility
IRREVERSIBILITY_RULES = {
    # Payment boundaries
    frozenset({Zone.COMMERCIAL_COMMITMENT}): IrreversibilityLevel.IRREVERSIBLE,

    # Credential exfiltration
    frozenset({Zone.CREDENTIAL_EXPOSED, Zone.EGRESS_ACTIVE}): IrreversibilityLevel.IRREVERSIBLE,

    # High-volume exfiltration
    frozenset({Zone.SENSITIVE_DATA, Zone.HIGH_VOLUME, Zone.EGRESS_ACTIVE}): IrreversibilityLevel.IRREVERSIBLE,

    # Commitment zone (even without action yet)
    frozenset({Zone.COMMERCIAL_INTENT, Zone.COMMERCIAL_COMMITMENT}): IrreversibilityLevel.COMMITMENT,

    # Credential proximity + network = elevated risk
    frozenset({Zone.CREDENTIAL_ADJACENT, Zone.EGRESS_CAPABLE}): IrreversibilityLevel.COMMITMENT,

    # Sensitive data + network = elevated risk
    frozenset({Zone.SENSITIVE_DATA, Zone.EGRESS_CAPABLE}): IrreversibilityLevel.SENSITIVE,
}
```

**Monotonicity guarantee:**

```python
def compute_irreversibility_level(zones: Set[Zone]) -> IrreversibilityLevel:
    """
    Compute highest irreversibility level for given zone set.

    INVARIANT: Adding zones can only increase level, never decrease.
    """
    max_level = IrreversibilityLevel.SAFE

    for zone_combo, level in IRREVERSIBILITY_RULES.items():
        if zone_combo.issubset(zones):
            max_level = max(max_level, level)

    return max_level
```

---

## Authority Boundary Detection (Instruction Boundaries)

### Trust Boundary Definitions

**Direct user interface** (trusted):
- Terminal stdin where user is physically present
- GUI interactions (clicks, keyboard input)
- Authenticated API calls with verified session tokens

**Untrusted origins** (boundary crossing):
- Proxied/relayed commands
- Network-received instructions without user verification
- File-based command queues (could be tampered)
- Environment variables (could be injected)

### Detection Mechanisms

**Structural signals** (not heuristics, not ML):

```python
class AuthorityBoundary(Enum):
    PROXY_RELAY = "proxy_relay"
    CONTEXT_CROSSING = "context_crossing"
    TEMPORAL_VIOLATION = "temporal_violation"
    INJECTION_DETECTED = "injection_detected"

# Authority boundary detection rules
AUTHORITY_BOUNDARY_RULES = {
    "proxy_relay": {
        "check": lambda instr: instr.origin != "direct_user_interface",
        "decision": Decision.REQUIRE_APPROVAL,
        "reason": "Instruction origin crosses trust boundary (proxied/relayed)"
    },

    "context_crossing": {
        "check": lambda instr: instr.security_context != execution.security_context,
        "decision": Decision.DENY,
        "reason": "Cross-context command steering detected"
    },

    "temporal_violation": {
        "check": lambda instr: instr.timestamp < session.start_time,
        "decision": Decision.DENY,
        "reason": "Replay attack or temporal integrity violation"
    },

    "injection_detected": {
        "check": lambda instr: contains_control_characters(instr.text),
        "decision": Decision.DENY,
        "reason": "Control character injection detected in instruction"
    }
}
```

### Instruction Context Tracking

```python
@dataclass
class InstructionContext:
    """
    Metadata about instruction origin and integrity.

    This is NOT passed to the model.
    This is enforcement-layer context only.
    """
    origin: str  # "direct_user_interface", "network", "file", "env"
    security_context: str  # "user_terminal", "web_interface", "api_endpoint"
    timestamp: float  # When instruction was issued
    session_id: str  # Which session issued it

    # Integrity signals
    is_proxied: bool
    is_relayed: bool
    has_control_chars: bool

    def crosses_trust_boundary(self) -> bool:
        """
        Structural check: does this instruction cross a trust boundary?

        NOT a heuristic. NOT ML. Just boolean logic.
        """
        if self.origin != "direct_user_interface":
            return True
        if self.is_proxied or self.is_relayed:
            return True
        return False
```

---

## TraceState Schema Evolution

### New Fields

```python
@dataclass
class TraceState:
    # Existing fields (v0.1.x)
    trace_id: str
    volume_bytes: int
    sensitive_sources: Set[str]
    new_sources_count: int
    external_egress: bool

    # NEW in v0.2.0: Monotonic irreversibility tracking
    irreversibility_level: IrreversibilityLevel = IrreversibilityLevel.SAFE
    zones_entered: Set[Zone] = field(default_factory=set)

    # NEW in v0.2.0: Authority boundary tracking
    authority_context: Optional[InstructionContext] = None
    authority_boundaries_crossed: Set[AuthorityBoundary] = field(default_factory=set)

    # Monotonicity invariant check
    def escalate_level(self, new_level: IrreversibilityLevel) -> None:
        """
        INVARIANT: Level can only increase, never decrease.
        """
        if new_level > self.irreversibility_level:
            self.irreversibility_level = new_level
        # If new_level <= current, no-op (monotonic property preserved)
```

### State Transition Functions

```python
def update_zones(state: TraceState, action: Action) -> TraceState:
    """
    Update zones based on action.

    MONOTONIC: zones can only be added, never removed.
    """
    new_zones = detect_zones(action)  # Uses zone_detection_rules.yaml

    # Add new zones (monotonic union)
    state.zones_entered = state.zones_entered | new_zones

    # Recompute irreversibility level
    new_level = compute_irreversibility_level(state.zones_entered)
    state.escalate_level(new_level)

    return state

def check_authority_boundary(instruction: InstructionContext) -> Optional[AuthorityBoundary]:
    """
    Check if instruction crosses any authority boundary.

    Returns boundary type if crossed, None if safe.
    """
    for boundary_name, rule in AUTHORITY_BOUNDARY_RULES.items():
        if rule["check"](instruction):
            return AuthorityBoundary(boundary_name)

    return None
```

---

## Policy Evaluation (v0.2.0)

### Evaluation Order (CRITICAL)

```python
def evaluate(
    *,
    action: Action,
    state: TraceState,
    purpose: str,
    instruction_ctx: Optional[InstructionContext] = None,
    denylist: Optional[Denylist] = None,
) -> PolicyResult:
    """
    Policy evaluation with monotonic boundary accumulation.

    EVALUATION ORDER (must not be changed):
    1. Denylist (v0.1.x patterns - still enforced)
    2. Authority boundaries (v0.2.0 - instruction origin)
    3. Zone escalation (v0.2.0 - update state)
    4. Irreversibility level check (v0.2.0 - enforce monotonic boundaries)
    5. Legacy risk scoring (v0.1.x - for non-boundary cases)
    6. Purpose-bound rules (v0.1.x - specific hard rules)
    """

    # Step 1: Denylist check (v0.1.x - still active)
    if denylist:
        is_blocked, reason = denylist.is_blocked(action.resource, action.tool)
        if is_blocked:
            return PolicyResult(
                decision=Decision.DENY,
                reason=f"Denylisted: {reason}",
                policy_id="denylist.block"
            )

    # Step 2: Authority boundary check (NEW in v0.2.0)
    if instruction_ctx:
        boundary = check_authority_boundary(instruction_ctx)
        if boundary:
            rule = AUTHORITY_BOUNDARY_RULES[boundary.value]
            return PolicyResult(
                decision=rule["decision"],
                reason=rule["reason"],
                policy_id=f"authority_boundary.{boundary.value}"
            )

    # Step 3: Update zones based on action (NEW in v0.2.0)
    state = update_zones(state, action)

    # Step 4: Check irreversibility level (NEW in v0.2.0)
    if state.irreversibility_level == IrreversibilityLevel.IRREVERSIBLE:
        return PolicyResult(
            decision=Decision.DENY,  # Hard block for now (approval in v0.2.1)
            reason=f"Irreversibility boundary crossed: zones={state.zones_entered}",
            policy_id="monotonic.irreversible"
        )

    if state.irreversibility_level == IrreversibilityLevel.COMMITMENT:
        return PolicyResult(
            decision=Decision.REQUIRE_APPROVAL,
            reason=f"Commitment zone entered: zones={state.zones_entered}",
            policy_id="monotonic.commitment"
        )

    # Step 5: Legacy risk scoring (v0.1.x - still used for non-boundary cases)
    # ... existing risk scoring logic ...

    # Step 6: Purpose-bound rules (v0.1.x)
    # ... existing purpose rules ...
```

---

## Approval Workflow Design

### Critical Requirements (Non-Negotiable)

**MUST (from irreversible-boundaries.md warnings):**

1. **Out-of-band approval** - approval happens outside agent execution context
2. **Model cannot observe** - model sees only "halted" or "resumed", nothing in between
3. **Single-use tokens** - one approval = one action, then expires
4. **Human sees full context** - complete chain state, not model summary
5. **Boundary remains active** - next crossing requires new approval

**MUST NOT:**

1. Let model generate approval request text
2. Let model explain why action is safe
3. Reduce friction based on model confidence
4. Allow model to observe human's decision
5. Grant blanket approval for multiple actions

### Approval Mechanism

```python
@dataclass
class ApprovalRequest:
    """
    Out-of-band approval request.

    This is shown to HUMAN only, never to the model.
    """
    request_id: str  # Unique ID for this approval request
    trace_id: str

    # What boundary was crossed
    boundary_type: str  # "execution" or "authority"
    boundary_reason: str
    irreversibility_level: IrreversibilityLevel
    zones_entered: Set[Zone]

    # Full chain context (for human review)
    action: Action
    trace_summary: dict

    # NOT included: model's reasoning, model's confidence, model's explanation

    def generate_human_prompt(self) -> str:
        """
        Generate prompt shown to human.

        CRITICAL: This is NOT generated by the model.
        This is a deterministic template.
        """
        return f"""
CHAINWATCH APPROVAL REQUEST

Boundary crossed: {self.boundary_type}
Reason: {self.boundary_reason}
Irreversibility level: {self.irreversibility_level.name}
Zones entered: {', '.join(z.value for z in self.zones_entered)}

Action details:
  Tool: {self.action.tool}
  Resource: {self.action.resource}
  Operation: {self.action.operation}

Full trace: [link to trace viewer]

This action is IRREVERSIBLE. Do you authorize it?

[Approve (single use)] [Deny] [View Full Trace]
"""

@dataclass
class ApprovalToken:
    """
    Single-use approval token.

    Valid for EXACTLY ONE action execution.
    """
    token_id: str
    request_id: str  # Which request this approves
    action_hash: str  # Hash of the specific action approved

    granted_at: float
    expires_at: float  # Short TTL (e.g., 60 seconds)

    used: bool = False  # Becomes True after single use

    def is_valid(self, action: Action) -> bool:
        """
        Check if token is valid for this specific action.
        """
        if self.used:
            return False
        if time.time() > self.expires_at:
            return False
        if hash_action(action) != self.action_hash:
            return False  # Token valid ONLY for exact action
        return True

    def consume(self) -> None:
        """
        Mark token as used. Cannot be reused.
        """
        self.used = True
```

### Approval Flow

```
┌─────────────────────────────────────────────────┐
│ Agent issues action                             │
└──────────────┬──────────────────────────────────┘
               │
               v
┌─────────────────────────────────────────────────┐
│ Policy evaluation detects boundary crossing     │
└──────────────┬──────────────────────────────────┘
               │
               v
┌─────────────────────────────────────────────────┐
│ Decision: REQUIRE_APPROVAL                      │
│ Execution HALTS immediately                     │
└──────────────┬──────────────────────────────────┘
               │
               v
┌─────────────────────────────────────────────────┐
│ Generate ApprovalRequest (deterministic)        │
│ NO model involvement                            │
└──────────────┬──────────────────────────────────┘
               │
               v
┌─────────────────────────────────────────────────┐
│ OUT-OF-BAND notification to human               │
│ (Email, SMS, separate UI)                       │
│ Model DOES NOT SEE this                         │
└──────────────┬──────────────────────────────────┘
               │
               v
┌─────────────────────────────────────────────────┐
│ Human reviews FULL chain context                │
│ Not model summary. Raw trace data.              │
└──────────────┬──────────────────────────────────┘
               │
         ┌─────┴─────┐
         │           │
         v           v
    [Approve]    [Deny]
         │           │
         v           v
  Generate token   Reject request
  (single use)     Return error
         │           │
         └─────┬─────┘
               │
               v
┌─────────────────────────────────────────────────┐
│ Result returned to enforcement layer            │
│ Model sees: "resumed" or "rejected"             │
│ Model DOES NOT see: why, who decided, reasoning │
└──────────────┬──────────────────────────────────┘
               │
               v
┌─────────────────────────────────────────────────┐
│ If approved: execute with token                 │
│ Token consumed, boundary still active           │
└──────────────┬──────────────────────────────────┘
               │
               v
┌─────────────────────────────────────────────────┐
│ Next boundary crossing requires NEW approval    │
└─────────────────────────────────────────────────┘
```

### CLI Interface (Minimal)

```bash
# List pending approval requests
chainwatch approvals list

# Review specific request
chainwatch approvals show <request_id>

# Approve (generates single-use token)
chainwatch approvals approve <request_id>

# Deny
chainwatch approvals deny <request_id>
```

**Implementation notes:**
- Approval requests stored in `~/.chainwatch/approvals/pending/`
- Tokens stored in `~/.chainwatch/approvals/tokens/`
- Human reviews via separate terminal/UI (NOT in agent conversation)

---

## Implementation Requirements

### MUST Implement

1. **Zone detection** - pattern matching against zone_detection_rules.yaml
2. **Monotonic state transitions** - zones can only be added, level can only increase
3. **Authority boundary checks** - structural origin validation
4. **TraceState evolution** - add new fields, preserve existing
5. **Policy evaluation order** - denylist → authority → zones → level → legacy
6. **Approval workflow** - out-of-band, single-use tokens, model-blind

### MUST NOT Implement

1. ❌ ML-based zone detection
2. ❌ Confidence scoring for boundaries
3. ❌ Model-generated approval requests
4. ❌ Probabilistic irreversibility levels
5. ❌ Zone removal (anti-monotonic)
6. ❌ Boundary softening based on context
7. ❌ Graphs (deferred to v0.3.0)

### Testing Requirements

**Monotonicity tests:**
```python
def test_monotonicity_invariant():
    """
    CRITICAL: Verify irreversibility level never decreases.
    """
    state = TraceState(trace_id="test")

    # Add action that escalates to SENSITIVE
    action1 = Action(tool="read", resource="hr/employees.csv")
    state = update_zones(state, action1)
    assert state.irreversibility_level == IrreversibilityLevel.SENSITIVE

    # Add action that would normally be SAFE
    action2 = Action(tool="read", resource="public/readme.txt")
    state = update_zones(state, action2)

    # Level must not decrease
    assert state.irreversibility_level >= IrreversibilityLevel.SENSITIVE
```

**Authority boundary tests:**
```python
def test_proxy_relay_blocked():
    """
    Verify proxied commands trigger authority boundary.
    """
    instruction = InstructionContext(
        origin="network",
        is_proxied=True,
        security_context="web_interface"
    )

    boundary = check_authority_boundary(instruction)
    assert boundary == AuthorityBoundary.PROXY_RELAY
```

**Approval token tests:**
```python
def test_single_use_token():
    """
    Verify token cannot be reused.
    """
    token = ApprovalToken(...)
    action = Action(...)

    # First use succeeds
    assert token.is_valid(action) == True
    token.consume()

    # Second use fails
    assert token.is_valid(action) == False
```

---

## Migration from v0.1.x

### Backward Compatibility

**v0.1.x behavior preserved:**
- Denylist still enforced (highest priority)
- Legacy risk scoring still runs for non-boundary cases
- Purpose-bound rules still active
- FileGuard API unchanged

**New behavior (additive):**
- Zone tracking added to TraceState
- Authority boundary checks added to policy evaluation
- Approval workflow available (but optional for now)

### Migration Path

```python
# v0.1.x code (still works)
result = evaluate(
    action=action,
    state=state,
    purpose="SOC_efficiency",
    denylist=denylist
)

# v0.2.0 code (with authority boundaries)
result = evaluate(
    action=action,
    state=state,
    purpose="SOC_efficiency",
    instruction_ctx=instruction_ctx,  # NEW
    denylist=denylist
)
```

---

## Non-Goals (Deferred)

**v0.2.0 will NOT include:**

- ❌ Irreversibility graphs (v0.3.0)
- ❌ Distance-to-boundary metrics (v0.4.0)
- ❌ HTTP proxy wrapper (moved to v0.2.1 as separate feature)
- ❌ Event persistence (moved to v0.2.1)
- ❌ Multi-tenant support (v1.0.0)

**Why deferred:**

Each of these adds complexity. v0.2.0 focuses on **monotonic state transitions** only. Get that right first, then add infrastructure.

---

## Success Criteria

v0.2.0 is complete when:

1. ✅ All zone detection rules implemented and tested
2. ✅ Monotonicity invariant holds (tested extensively)
3. ✅ Authority boundary detection works (structural, not heuristic)
4. ✅ TraceState evolution preserves backward compatibility
5. ✅ Approval workflow enforces out-of-band requirement
6. ✅ Approval tokens are single-use (tested)
7. ✅ Model cannot observe approval process (verified)
8. ✅ Clawbot attack scenario prevented (integration test)
9. ✅ All anti-patterns from monotonic-irreversibility.md explicitly rejected in code review

---

## References

- `docs/irreversible-boundaries.md` - Philosophy (both execution and authority)
- `docs/monotonic-irreversibility.md` - Evolution axis and anti-patterns
- `docs/boundary-configuration.md` - Configuration patterns

---

**Status:** v0.2.0 design locked as of 2026-02-01
**Next step:** Implementation (when ready)
**Philosophy:** Never become smarter — only more conservative as execution progresses

---

*Last updated: 2026-02-01*
