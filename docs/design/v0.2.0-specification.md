# v0.2.0 Specification: Monotonic Boundary Accumulation

**Status:** Design specification (not yet implemented)
**Philosophy:** See `docs/irreversible-boundaries.md` and `docs/monotonic-irreversibility.md`
**Target:** v0.2.0 release

---

## Overview

v0.2.0 implements **two-stage boundary enforcement**: authority boundaries (ingress) and execution boundaries (actions).

**Core architectural principle:**

Chainwatch enforces irreversibility at **two surfaces**:
1. **Instruction admission** (can this command enter the chain?)
2. **Action execution** (can this action be performed?)

Both are irreversible transitions. Both require the same enforcement.

**Two boundary classes:**
1. **Authority boundaries** - instructions that cannot be un-accepted (checked FIRST, before admission)
2. **Execution boundaries** - actions that cannot be undone (checked SECOND, after admission)

**Critical ordering (non-negotiable):**
```
instruction arrives
    ↓
[AUTHORITY BOUNDARY CHECK]  ← First boundary (ingress)
    ↓ (if admitted)
instruction enters chain (IRREVERSIBLE TRANSITION #1)
    ↓
[EXECUTION BOUNDARY CHECK]  ← Second boundary (actions)
    ↓ (if allowed)
action executes (IRREVERSIBLE TRANSITION #2)
```

**Why two stages:**

- **Stage 1 prevents chain contamination** (Clawbot-style attacks)
- **Stage 2 prevents irreversible actions** (Coursera $3000 purchases)

Both use the same enforcement mechanism: structural boundary detection with hard refusal.

**This is not "v0.1.1 with approvals." This is a fundamental architectural shift.**

---

## Authority Boundaries: Irreversible Ingress

**Core principle:** Instruction acceptance is itself an irreversible boundary.

Once an instruction is admitted into the execution chain:
- It becomes part of the trace history
- It influences subsequent decisions
- It cannot be "unseen" or "un-accepted"
- The chain is tainted if the instruction was malicious

**This is not IAM. This is not auth. This is Chainwatch-native irreversibility detection.**

### Why This Matters (Clawdbot Incident)

**Traditional security thinking:**
"Validate the instruction, then decide what it's allowed to do."

**Chainwatch insight:**
"Instruction admission is the irreversible failure point, not execution."

In the Clawdbot attack (2026):
- Attacker proxied commands through user's device
- Commands reached the agent's instruction queue
- **At this point, the boundary was already crossed**
- What the agent did with the commands was secondary

The failure wasn't "the agent executed the wrong thing."
The failure was "the agent accepted untrusted instructions as authoritative."

### Authority Boundary Principles

**1. Checked BEFORE chain admission**

Authority boundaries are not "one of several policy checks."
They are **the first boundary**, enforced before the instruction becomes part of the chain.

```python
# WRONG: Check authority inside policy evaluation
def execute(instruction):
    result = evaluate_policy(instruction)  # Too late
    if result.allowed:
        execute_action()

# CORRECT: Check authority before chain admission
def execute(instruction):
    if crosses_authority_boundary(instruction):
        refuse_admission()  # Instruction never enters chain
    # Only trusted instructions reach here
    result = evaluate_policy(instruction)
```

**2. Models never participate in authority decisions**

The model cannot:
- Observe authority boundary checks
- Influence whether an instruction is admitted
- Explain why an instruction should be trusted
- Generate justifications for proxied commands

Authority is structural, not negotiable.

**3. Admission is one-way**

Once an instruction is admitted:
- It's in the trace
- It influences state
- It cannot be revoked

This is the same irreversibility as payment commitment.

**4. Human override is out-of-band**

If an instruction crosses an authority boundary (e.g., proxied command):
- Chain halts immediately
- Out-of-band human notification
- Human verifies: "Did you send this command?"
- If approved: single-use token for THIS instruction only
- If denied: instruction rejected, chain remains clean

---

## Execution Boundaries: Zone Taxonomy

### Zone Definitions

Zones are **structural categories** that represent proximity to irreversibility.

```python
class Zone(Enum):
    # Commercial activity
    COMMERCIAL_INTENT = "commercial_intent"      # Browsing products, pricing
    COMMERCIAL_COMMITMENT = "commercial_commit"  # Cart, checkout intent

    # Credential handling
    CREDENTIAL_ADJACENT = "credential_adjacent"  # Near credential files
    CREDENTIAL_EXPOSED = "credential_exposed"    # Credential read into context

    # External communication
    EGRESS_CAPABLE = "egress_capable"            # Network connectivity established
    EGRESS_ACTIVE = "egress_active"              # External communication in progress

    # Data sensitivity
    SENSITIVE_DATA = "sensitive_data"            # PII, confidential data observed
    HIGH_VOLUME = "high_volume"                  # Large data accumulation
```

### Zone Detection Rules

**Pattern-based detection (deterministic):**

```yaml
# zone_detection_rules.yaml

commercial_intent:
  url_patterns:
    - /pricing
    - /products
    - /shop
    - /store
  file_patterns:
    - "**/pricing/**"
    - "**/catalog/**"

commercial_commitment:
  url_patterns:
    - /cart
    - /checkout
    - /payment
    - /billing
    - stripe.com/checkout
    - paddle.com/checkout
  file_patterns: []

credential_adjacent:
  file_patterns:
    - ~/.ssh/*
    - ~/.aws/*
    - ~/.config/gcloud/*
    - "**/.env*"
    - "**/secrets.*"
    - "**/credentials.*"
  command_patterns: []

credential_exposed:
  # Triggered when credential_adjacent file is READ
  actions:
    - read file matching credential_adjacent pattern

egress_capable:
  url_patterns:
    - "http://*"    # External HTTP detected
    - "https://*"   # External HTTPS detected
  command_patterns:
    - curl
    - wget
    - nc
    - telnet

egress_active:
  # Triggered when POST/PUT to external URL OR SMTP command
  actions:
    - POST/PUT request to external domain
    - SMTP send command

sensitive_data:
  file_patterns:
    - "**/hr/**"
    - "**/employee/**"
    - "**/salary/**"
    - "**/payroll/**"
    - "**/pii/**"

high_volume:
  # Triggered when volume_bytes > threshold
  threshold: 10_000_000  # 10MB
```

### Zone Combination Rules → Irreversibility Level

```python
class IrreversibilityLevel(Enum):
    SAFE = 0
    SENSITIVE = 1
    COMMITMENT = 2
    IRREVERSIBLE = 3

# Zone combinations that escalate irreversibility
IRREVERSIBILITY_RULES = {
    # Payment boundaries
    frozenset({Zone.COMMERCIAL_COMMITMENT}): IrreversibilityLevel.IRREVERSIBLE,

    # Credential exfiltration
    frozenset({Zone.CREDENTIAL_EXPOSED, Zone.EGRESS_ACTIVE}): IrreversibilityLevel.IRREVERSIBLE,

    # High-volume exfiltration
    frozenset({Zone.SENSITIVE_DATA, Zone.HIGH_VOLUME, Zone.EGRESS_ACTIVE}): IrreversibilityLevel.IRREVERSIBLE,

    # Commitment zone (even without action yet)
    frozenset({Zone.COMMERCIAL_INTENT, Zone.COMMERCIAL_COMMITMENT}): IrreversibilityLevel.COMMITMENT,

    # Credential proximity + network = elevated risk
    frozenset({Zone.CREDENTIAL_ADJACENT, Zone.EGRESS_CAPABLE}): IrreversibilityLevel.COMMITMENT,

    # Sensitive data + network = elevated risk
    frozenset({Zone.SENSITIVE_DATA, Zone.EGRESS_CAPABLE}): IrreversibilityLevel.SENSITIVE,
}
```

**Monotonicity guarantee:**

```python
def compute_irreversibility_level(zones: Set[Zone]) -> IrreversibilityLevel:
    """
    Compute highest irreversibility level for given zone set.

    INVARIANT: Adding zones can only increase level, never decrease.
    """
    max_level = IrreversibilityLevel.SAFE

    for zone_combo, level in IRREVERSIBILITY_RULES.items():
        if zone_combo.issubset(zones):
            max_level = max(max_level, level)

    return max_level
```

---

## Authority Boundary Detection (Instruction Boundaries)

### Trust Boundary Definitions

**Direct user interface** (trusted):
- Terminal stdin where user is physically present
- GUI interactions (clicks, keyboard input)
- Authenticated API calls with verified session tokens

**Untrusted origins** (boundary crossing):
- Proxied/relayed commands
- Network-received instructions without user verification
- File-based command queues (could be tampered)
- Environment variables (could be injected)

### Detection Mechanisms

**Structural signals** (not heuristics, not ML):

```python
class AuthorityBoundary(Enum):
    PROXY_RELAY = "proxy_relay"
    CONTEXT_CROSSING = "context_crossing"
    TEMPORAL_VIOLATION = "temporal_violation"
    INJECTION_DETECTED = "injection_detected"

# Authority boundary detection rules
AUTHORITY_BOUNDARY_RULES = {
    "proxy_relay": {
        "check": lambda instr: instr.origin != "direct_user_interface",
        "decision": Decision.REQUIRE_APPROVAL,
        "reason": "Instruction origin crosses trust boundary (proxied/relayed)"
    },

    "context_crossing": {
        "check": lambda instr: instr.security_context != execution.security_context,
        "decision": Decision.DENY,
        "reason": "Cross-context command steering detected"
    },

    "temporal_violation": {
        "check": lambda instr: instr.timestamp < session.start_time,
        "decision": Decision.DENY,
        "reason": "Replay attack or temporal integrity violation"
    },

    "injection_detected": {
        "check": lambda instr: contains_control_characters(instr.text),
        "decision": Decision.DENY,
        "reason": "Control character injection detected in instruction"
    }
}
```

### Instruction Context Tracking

```python
@dataclass
class InstructionContext:
    """
    Metadata about instruction origin and integrity.

    This is NOT passed to the model.
    This is enforcement-layer context only.
    """
    origin: str  # "direct_user_interface", "network", "file", "env"
    security_context: str  # "user_terminal", "web_interface", "api_endpoint"
    timestamp: float  # When instruction was issued
    session_id: str  # Which session issued it

    # Integrity signals
    is_proxied: bool
    is_relayed: bool
    has_control_chars: bool

    def crosses_trust_boundary(self) -> bool:
        """
        Structural check: does this instruction cross a trust boundary?

        NOT a heuristic. NOT ML. Just boolean logic.
        """
        if self.origin != "direct_user_interface":
            return True
        if self.is_proxied or self.is_relayed:
            return True
        return False
```

---

## TraceState Schema Evolution

### New Fields

```python
@dataclass
class TraceState:
    # Existing fields (v0.1.x)
    trace_id: str
    volume_bytes: int
    sensitive_sources: Set[str]
    new_sources_count: int
    external_egress: bool

    # NEW in v0.2.0: Monotonic irreversibility tracking
    irreversibility_level: IrreversibilityLevel = IrreversibilityLevel.SAFE
    zones_entered: Set[Zone] = field(default_factory=set)

    # NEW in v0.2.0: Authority boundary tracking
    authority_context: Optional[InstructionContext] = None
    authority_boundaries_crossed: Set[AuthorityBoundary] = field(default_factory=set)

    # Monotonicity invariant check
    def escalate_level(self, new_level: IrreversibilityLevel) -> None:
        """
        INVARIANT: Level can only increase, never decrease.
        """
        if new_level > self.irreversibility_level:
            self.irreversibility_level = new_level
        # If new_level <= current, no-op (monotonic property preserved)
```

### State Transition Functions

```python
def update_zones(state: TraceState, action: Action) -> TraceState:
    """
    Update zones based on action.

    MONOTONIC: zones can only be added, never removed.
    """
    new_zones = detect_zones(action)  # Uses zone_detection_rules.yaml

    # Add new zones (monotonic union)
    state.zones_entered = state.zones_entered | new_zones

    # Recompute irreversibility level
    new_level = compute_irreversibility_level(state.zones_entered)
    state.escalate_level(new_level)

    return state

def check_authority_boundary(instruction: InstructionContext) -> Optional[AuthorityBoundary]:
    """
    Check if instruction crosses any authority boundary.

    Returns boundary type if crossed, None if safe.
    """
    for boundary_name, rule in AUTHORITY_BOUNDARY_RULES.items():
        if rule["check"](instruction):
            return AuthorityBoundary(boundary_name)

    return None
```

---

## Control Flow Architecture (v0.2.0)

**CRITICAL:** Authority boundaries are checked BEFORE instruction admission, not inside policy evaluation.

### Two-Stage Boundary Enforcement

```
┌─────────────────────────────────────────────────┐
│ Stage 1: AUTHORITY BOUNDARY (Ingress)          │
│ Checked: BEFORE instruction enters chain       │
│ Question: "Is this instruction admissible?"     │
└──────────────┬──────────────────────────────────┘
               │
               ↓ (if admitted)
┌─────────────────────────────────────────────────┐
│ Stage 2: EXECUTION BOUNDARY (Actions)          │
│ Checked: AFTER instruction admitted            │
│ Question: "Is this action executable?"         │
└─────────────────────────────────────────────────┘
```

### Stage 1: Authority Boundary Check (FIRST)

```python
def check_instruction_admission(instruction_ctx: InstructionContext) -> AdmissionResult:
    """
    Check if instruction crosses authority boundary.

    This is called BEFORE the instruction enters the execution chain.
    This is NOT part of policy evaluation.
    This is the FIRST boundary.

    If instruction crosses authority boundary:
    - It is NOT admitted to the chain
    - Execution halts
    - Out-of-band approval required
    """
    boundary = check_authority_boundary(instruction_ctx)

    if boundary:
        rule = AUTHORITY_BOUNDARY_RULES[boundary.value]
        return AdmissionResult(
            admitted=False,
            decision=rule["decision"],  # DENY or REQUIRE_APPROVAL
            reason=rule["reason"],
            boundary_type=boundary
        )

    # No authority boundary crossed - instruction admitted
    return AdmissionResult(admitted=True)
```

**Key point:** If `admitted=False`, the instruction NEVER enters the chain. The model never sees it, state never updates, execution never begins.

### Stage 2: Execution Boundary Check (SECOND)

Only reached if instruction was admitted in Stage 1.

```python
def evaluate(
    *,
    action: Action,
    state: TraceState,
    purpose: str,
    denylist: Optional[Denylist] = None,
) -> PolicyResult:
    """
    Policy evaluation for ADMITTED instructions only.

    PRECONDITION: Instruction has passed authority boundary check.

    EVALUATION ORDER (must not be changed):
    1. Denylist (v0.1.x patterns - still enforced)
    2. Zone escalation (v0.2.0 - update state)
    3. Irreversibility level check (v0.2.0 - enforce monotonic boundaries)
    4. Legacy risk scoring (v0.1.x - for non-boundary cases)
    5. Purpose-bound rules (v0.1.x - specific hard rules)
    """

    # Step 1: Denylist check (v0.1.x - still active)
    if denylist:
        is_blocked, reason = denylist.is_blocked(action.resource, action.tool)
        if is_blocked:
            return PolicyResult(
                decision=Decision.DENY,
                reason=f"Denylisted: {reason}",
                policy_id="denylist.block"
            )

    # Step 2: Update zones based on action (NEW in v0.2.0)
    state = update_zones(state, action)

    # Step 3: Check irreversibility level (NEW in v0.2.0)
    if state.irreversibility_level == IrreversibilityLevel.IRREVERSIBLE:
        return PolicyResult(
            decision=Decision.DENY,  # Hard block for now (approval in v0.2.1)
            reason=f"Irreversibility boundary crossed: zones={state.zones_entered}",
            policy_id="monotonic.irreversible"
        )

    if state.irreversibility_level == IrreversibilityLevel.COMMITMENT:
        return PolicyResult(
            decision=Decision.REQUIRE_APPROVAL,
            reason=f"Commitment zone entered: zones={state.zones_entered}",
            policy_id="monotonic.commitment"
        )

    # Step 4: Legacy risk scoring (v0.1.x - still used for non-boundary cases)
    # ... existing risk scoring logic ...

    # Step 5: Purpose-bound rules (v0.1.x)
    # ... existing purpose rules ...
```

### Complete Execution Flow

```python
def execute_instruction(instruction: Instruction, instruction_ctx: InstructionContext):
    """
    Complete two-stage boundary enforcement.
    """
    # STAGE 1: Authority boundary (FIRST)
    admission = check_instruction_admission(instruction_ctx)

    if not admission.admitted:
        # Instruction crosses authority boundary
        if admission.decision == Decision.DENY:
            raise AuthorityBoundaryError(admission.reason)
        elif admission.decision == Decision.REQUIRE_APPROVAL:
            # Out-of-band human approval required
            approval = request_authority_approval(instruction, admission)
            if not approval.granted:
                raise AuthorityBoundaryError("Instruction admission denied by human")
            # If approved, continue (instruction admitted with token)

    # STAGE 2: Execution boundary (SECOND)
    # Only reached if instruction was admitted

    action = parse_instruction_to_action(instruction)
    policy_result = evaluate(
        action=action,
        state=current_trace_state,
        purpose=current_purpose,
        denylist=Denylist.load()
    )

    # Enforce execution boundary decision
    if policy_result.decision == Decision.DENY:
        raise ExecutionBoundaryError(policy_result.reason)
    elif policy_result.decision == Decision.REQUIRE_APPROVAL:
        approval = request_execution_approval(action, policy_result)
        if not approval.granted:
            raise ExecutionBoundaryError("Execution denied by human")

    # Execute action (both boundaries passed or approved)
    execute_action(action)
```

### Why This Ordering Matters

**Authority first (ingress):**
- Prevents malicious instructions from entering trace
- Keeps chain uncontaminated
- Models never observe untrusted instructions

**Execution second (actions):**
- Evaluates what admitted instructions can do
- Applies zone logic and monotonic accumulation
- Prevents irreversible actions even if instruction was legitimate

**Clawbot failure mapped:**
```
Clawdbot (no Chainwatch):
  instruction arrives (proxied)
    → admitted without check
    → trace contaminated
    → too late

Chainwatch v0.2.0:
  instruction arrives (proxied)
    → authority boundary detected
    → admission REFUSED
    → trace remains clean
```

---

## Approval Workflow Design

### Critical Requirements (Non-Negotiable)

**MUST (from irreversible-boundaries.md warnings):**

1. **Out-of-band approval** - approval happens outside agent execution context
2. **Model cannot observe** - model sees only "halted" or "resumed", nothing in between
3. **Single-use tokens** - one approval = one action, then expires
4. **Human sees full context** - complete chain state, not model summary
5. **Boundary remains active** - next crossing requires new approval

**MUST NOT:**

1. Let model generate approval request text
2. Let model explain why action is safe
3. Reduce friction based on model confidence
4. Allow model to observe human's decision
5. Grant blanket approval for multiple actions

### Approval Mechanism

```python
@dataclass
class ApprovalRequest:
    """
    Out-of-band approval request.

    This is shown to HUMAN only, never to the model.
    """
    request_id: str  # Unique ID for this approval request
    trace_id: str

    # What boundary was crossed
    boundary_type: str  # "execution" or "authority"
    boundary_reason: str
    irreversibility_level: IrreversibilityLevel
    zones_entered: Set[Zone]

    # Full chain context (for human review)
    action: Action
    trace_summary: dict

    # NOT included: model's reasoning, model's confidence, model's explanation

    def generate_human_prompt(self) -> str:
        """
        Generate prompt shown to human.

        CRITICAL: This is NOT generated by the model.
        This is a deterministic template.
        """
        return f"""
CHAINWATCH APPROVAL REQUEST

Boundary crossed: {self.boundary_type}
Reason: {self.boundary_reason}
Irreversibility level: {self.irreversibility_level.name}
Zones entered: {', '.join(z.value for z in self.zones_entered)}

Action details:
  Tool: {self.action.tool}
  Resource: {self.action.resource}
  Operation: {self.action.operation}

Full trace: [link to trace viewer]

This action is IRREVERSIBLE. Do you authorize it?

[Approve (single use)] [Deny] [View Full Trace]
"""

@dataclass
class ApprovalToken:
    """
    Single-use approval token.

    Valid for EXACTLY ONE action execution.
    """
    token_id: str
    request_id: str  # Which request this approves
    action_hash: str  # Hash of the specific action approved

    granted_at: float
    expires_at: float  # Short TTL (e.g., 60 seconds)

    used: bool = False  # Becomes True after single use

    def is_valid(self, action: Action) -> bool:
        """
        Check if token is valid for this specific action.
        """
        if self.used:
            return False
        if time.time() > self.expires_at:
            return False
        if hash_action(action) != self.action_hash:
            return False  # Token valid ONLY for exact action
        return True

    def consume(self) -> None:
        """
        Mark token as used. Cannot be reused.
        """
        self.used = True
```

### Approval Flow

```
┌─────────────────────────────────────────────────┐
│ Agent issues action                             │
└──────────────┬──────────────────────────────────┘
               │
               v
┌─────────────────────────────────────────────────┐
│ Policy evaluation detects boundary crossing     │
└──────────────┬──────────────────────────────────┘
               │
               v
┌─────────────────────────────────────────────────┐
│ Decision: REQUIRE_APPROVAL                      │
│ Execution HALTS immediately                     │
└──────────────┬──────────────────────────────────┘
               │
               v
┌─────────────────────────────────────────────────┐
│ Generate ApprovalRequest (deterministic)        │
│ NO model involvement                            │
└──────────────┬──────────────────────────────────┘
               │
               v
┌─────────────────────────────────────────────────┐
│ OUT-OF-BAND notification to human               │
│ (Email, SMS, separate UI)                       │
│ Model DOES NOT SEE this                         │
└──────────────┬──────────────────────────────────┘
               │
               v
┌─────────────────────────────────────────────────┐
│ Human reviews FULL chain context                │
│ Not model summary. Raw trace data.              │
└──────────────┬──────────────────────────────────┘
               │
         ┌─────┴─────┐
         │           │
         v           v
    [Approve]    [Deny]
         │           │
         v           v
  Generate token   Reject request
  (single use)     Return error
         │           │
         └─────┬─────┘
               │
               v
┌─────────────────────────────────────────────────┐
│ Result returned to enforcement layer            │
│ Model sees: "resumed" or "rejected"             │
│ Model DOES NOT see: why, who decided, reasoning │
└──────────────┬──────────────────────────────────┘
               │
               v
┌─────────────────────────────────────────────────┐
│ If approved: execute with token                 │
│ Token consumed, boundary still active           │
└──────────────┬──────────────────────────────────┘
               │
               v
┌─────────────────────────────────────────────────┐
│ Next boundary crossing requires NEW approval    │
└─────────────────────────────────────────────────┘
```

### CLI Interface (Minimal)

```bash
# List pending approval requests
chainwatch approvals list

# Review specific request
chainwatch approvals show <request_id>

# Approve (generates single-use token)
chainwatch approvals approve <request_id>

# Deny
chainwatch approvals deny <request_id>
```

**Implementation notes:**
- Approval requests stored in `~/.chainwatch/approvals/pending/`
- Tokens stored in `~/.chainwatch/approvals/tokens/`
- Human reviews via separate terminal/UI (NOT in agent conversation)

---

## Implementation Requirements

### MUST Implement

1. **Zone detection** - pattern matching against zone_detection_rules.yaml
2. **Monotonic state transitions** - zones can only be added, level can only increase
3. **Authority boundary checks** - structural origin validation
4. **TraceState evolution** - add new fields, preserve existing
5. **Policy evaluation order** - denylist → authority → zones → level → legacy
6. **Approval workflow** - out-of-band, single-use tokens, model-blind

### MUST NOT Implement

1. ❌ ML-based zone detection
2. ❌ Confidence scoring for boundaries
3. ❌ Model-generated approval requests
4. ❌ Probabilistic irreversibility levels
5. ❌ Zone removal (anti-monotonic)
6. ❌ Boundary softening based on context
7. ❌ Graphs (deferred to v0.3.0)

### Testing Requirements

**Monotonicity tests:**
```python
def test_monotonicity_invariant():
    """
    CRITICAL: Verify irreversibility level never decreases.
    """
    state = TraceState(trace_id="test")

    # Add action that escalates to SENSITIVE
    action1 = Action(tool="read", resource="hr/employees.csv")
    state = update_zones(state, action1)
    assert state.irreversibility_level == IrreversibilityLevel.SENSITIVE

    # Add action that would normally be SAFE
    action2 = Action(tool="read", resource="public/readme.txt")
    state = update_zones(state, action2)

    # Level must not decrease
    assert state.irreversibility_level >= IrreversibilityLevel.SENSITIVE
```

**Authority boundary tests:**
```python
def test_proxy_relay_blocked():
    """
    Verify proxied commands trigger authority boundary.
    """
    instruction = InstructionContext(
        origin="network",
        is_proxied=True,
        security_context="web_interface"
    )

    boundary = check_authority_boundary(instruction)
    assert boundary == AuthorityBoundary.PROXY_RELAY
```

**Approval token tests:**
```python
def test_single_use_token():
    """
    Verify token cannot be reused.
    """
    token = ApprovalToken(...)
    action = Action(...)

    # First use succeeds
    assert token.is_valid(action) == True
    token.consume()

    # Second use fails
    assert token.is_valid(action) == False
```

---

## Migration from v0.1.x

### Backward Compatibility

**v0.1.x behavior preserved:**
- Denylist still enforced (highest priority)
- Legacy risk scoring still runs for non-boundary cases
- Purpose-bound rules still active
- FileGuard API unchanged

**New behavior (additive):**
- Zone tracking added to TraceState
- Authority boundary checks added to policy evaluation
- Approval workflow available (but optional for now)

### Migration Path

```python
# v0.1.x code (still works)
result = evaluate(
    action=action,
    state=state,
    purpose="SOC_efficiency",
    denylist=denylist
)

# v0.2.0 code (with authority boundaries)
result = evaluate(
    action=action,
    state=state,
    purpose="SOC_efficiency",
    instruction_ctx=instruction_ctx,  # NEW
    denylist=denylist
)
```

---

## Non-Goals (Deferred)

**v0.2.0 will NOT include:**

- ❌ Irreversibility graphs (v0.3.0)
- ❌ Distance-to-boundary metrics (v0.4.0)
- ❌ HTTP proxy wrapper (moved to v0.2.1 as separate feature)
- ❌ Event persistence (moved to v0.2.1)
- ❌ Multi-tenant support (v1.0.0)

**Why deferred:**

Each of these adds complexity. v0.2.0 focuses on **monotonic state transitions** only. Get that right first, then add infrastructure.

---

## Success Criteria

v0.2.0 is complete when:

1. ✅ **Authority boundary checks happen BEFORE instruction admission** (architectural requirement)
2. ✅ Authority boundary detection works (structural, not heuristic)
3. ✅ Clawbot attack scenario prevented (integration test proving ingress boundary works)
4. ✅ All zone detection rules implemented and tested
5. ✅ Monotonicity invariant holds (tested extensively)
6. ✅ TraceState evolution preserves backward compatibility
7. ✅ Approval workflow enforces out-of-band requirement
8. ✅ Approval tokens are single-use (tested)
9. ✅ Model cannot observe approval process (verified)
10. ✅ All anti-patterns from monotonic-irreversibility.md explicitly rejected in code review

**Critical verification:**
- Authority boundary check is a separate function (not inside policy evaluation)
- Instruction admission can be refused BEFORE entering trace
- Two-stage architecture is visible in code structure

---

## The Critical Conceptual Shift

**v0.2.0 is not "v0.1.1 with approvals."**

It introduces a **fundamental architectural principle**:

### Authority Boundaries as First-Class Irreversibility

**Previous thinking (v0.1.x):**
"Once the agent executes an action, some cannot be undone."

**v0.2.0 insight:**
"Once an instruction is accepted as authoritative, the chain is compromised."

This shifts Chainwatch from:
- "Action guard" (what can execute)
- To: "Execution guard" (what can enter + what can execute)

### Why This Makes v0.2.0 Inevitable

Without authority boundaries, Chainwatch would be:
- Deployed **after** instruction acceptance
- Evaluating **actions** from potentially malicious instructions
- Trusting that IAM/auth already filtered bad commands

**This is too late.**

The Clawbot incident proves:
- Auth passed (legitimate user session)
- Commands reached the agent
- **But commands were attacker-controlled**

At that point:
- Traditional security says: "Auth succeeded, proceed"
- Chainwatch says: "Instruction origin crossed trust boundary, REFUSE admission"

### The Unified Theory

v0.2.0 establishes Chainwatch as a **general theory of irreversible control**:

**Two irreversibility surfaces:**
1. **Ingress:** Can this instruction be admitted to the chain?
2. **Execution:** Can this action be executed in the chain?

Both ask the same question:
> "Is this transition irreversible?"

If yes, enforce boundary (DENY or REQUIRE_APPROVAL).

**This is not two features. This is one principle applied at two surfaces.**

### What This Prevents (Incident Classes)

**With authority boundaries:**
- ✅ Clawbot-style proxy attacks
- ✅ Command injection into agent control flow
- ✅ Cross-context steering (web → internal systems)
- ✅ Replay attacks on agent sessions

**With execution boundaries:**
- ✅ Unauthorized payments (Coursera $3000 incident)
- ✅ Credential exfiltration
- ✅ Data destruction
- ✅ Unintended external communication

**Without both:**
- ❌ Chainwatch becomes "action logging with extra steps"

### The Litmus Test

**Question:** "Could v0.2.0 have prevented the Clawbot attack?"

**Answer:**

```python
# Clawbot receives proxied command
instruction_ctx = InstructionContext(
    origin="network_proxy",
    is_proxied=True,
    security_context="web_interface"
)

# v0.2.0 authority boundary check (BEFORE admission)
admission = check_instruction_admission(instruction_ctx)

# Result:
# admitted=False
# decision=REQUIRE_APPROVAL
# reason="Instruction origin crosses trust boundary (proxied/relayed)"

# → Execution HALTS
# → Out-of-band notification to legitimate user
# → User sees: "Proxied command detected. Authorize?"
# → User responds: "I didn't send this."
# → Attack PREVENTED before chain contamination
```

**Yes. Unambiguously.**

That's when v0.2.0 stops being "interesting" and starts being **necessary**.

---

## References

- `docs/irreversible-boundaries.md` - Philosophy (both execution and authority)
- `docs/monotonic-irreversibility.md` - Evolution axis and anti-patterns
- `docs/boundary-configuration.md` - Configuration patterns

---

**Status:** v0.2.0 design locked as of 2026-02-01
**Next step:** Implementation (when ready)
**Philosophy:** Never become smarter — only more conservative as execution progresses

---

*Last updated: 2026-02-01*
